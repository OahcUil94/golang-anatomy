# Synchronized

`synchronized`既可以保证原子性, 又可以保证可见性, 所以加了synchronized是不需要加`volatile`

synchronized是可重入锁, 且必须是可重入锁

m1是加锁的, m2也是加锁的, m1调用m2的时候, 当m1获取到锁执行, 即使m2也需要获取锁才能执行, 也能继续执行m2 

如果程序出现异常, 锁一般会被释放, 这个是时候程序就会乱入, 其他线程进来抢占到锁, 而且会访问到产生异常的那些中间的数据

在早期的JDK版本中, 都是重量级的实现, 都是要找操作系统申请锁, 造成synchronized效率非常低

后来改进, 进行一种锁升级的操作, 偏向锁 -> 自旋锁 -> 重量级锁

synchronized(o), 在o这块内存的头部记录这个线程markword, 实际上没有加锁, 只是记录线程的id, 偏向锁, 偏向锁就是只记录线程的id, 由于通常是一个线程来执行, 所以它进行比对
如果还是同一个线程, 也不需要向操作系统申请锁了

如果有线程争用, 升级为自旋锁, 自旋10次之后, 再向操作系统去加这把锁 

在实际使用中, synchronized引入了锁升级的概念之后, 大多数情况下, 并不比atomic操作慢

升级成重量级锁之后, 这个线程就成为等待状态, 就不占CPU了, 锁只能升级不能降级

以上说的都是Hotspot的实现, 并不是JVM规范中的内容, 都是Oracle Hotspot的实现

atomic和其他的很多锁, 使用的都是自旋锁, 自旋锁的特点, 虽然占CPU但是不访问操作系统, 所以它是在用户态, 在用户态去解决锁的问题, 不经过内核态, 所以在加锁和解锁的效率上, 比经过内核态的效率要高
但是在什么情况下用自旋锁比较好, 用重量级锁比较好, 不占CPU的含义是: 旁边竞争的线程, 在等待队列里, 在那等着, 不占CPU, 什么时候CPU让你运行了, 你才能运行

执行时间长, 线程数多用重量级锁 
加锁代码执行时间特别短, 线程还不能太多用自旋锁 

synchronized(Object) Object不能是字符串常量, Integer, Long, 等基础的数据类型

Integer做了一些特殊的处理, Integer的值变一下就会变成一个新对象

Object为null的时候, 能不能当锁?

# CyclicBarrier

栅栏, 有些线程必须要等待其他几个线程完事了, 才能继续执行

# Phaser 

阶段, 遗传算法会用到

有一个场景, 结婚的场景, 婚礼会有很多个阶段, 

onAdvance: 前进, 线程抵达栅栏的时候, 满足了第一个条件的时候, 该方法会被自动调用
参数：
- phase是第几个阶段
- registeredParties: 目前在该阶段一共有几个人参加 

当onAdvance被调用的时候, 如果返回true, 整个phase的栅栏组就结束了

phaser.arriveAndAwaitAdvance
phaser.arriveAndDeregister
